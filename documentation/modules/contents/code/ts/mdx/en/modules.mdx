import { Title, SubTitle } from '@beyond/docs/titles';
import { Code } from '@beyond/docs/code';
import { Link, ELink } from '@beyond/docs/links';

<Title>Modules</Title>

<SubTitle>Introduction</SubTitle>

In BeyondJS, modules represent the basic unit of development and have features that need to be kept in mind. To fully understand the differences and advantages of the BeyondJS module ecosystem, it is first necessary to review how JavaScript modules work and how they are integrated into the development process today.

A <ELink to="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">JavaScript module</ELink> is represented by a single file, with independent tasks and its own scope. This module can export elements and be imported by other modules that consume the variables, objects, or functions it provides.

The bundle modules, for their part, usually use a syntax compatible with the imports included in EcmaScript 6. They are the ones who are in charge of analyzing the dependency tree, removing those elements that are not in the code, and generating a "bundle" that is in turn, a container of all the modules used by the development team.

In BeyondJS, the module concept is more encompassing and split into: Modules and Internal Modules.

<SubTitle>Internal Modules</SubTitle>

They represent the known concept of javascript modules, with the difference that the programmer can define whether they are available to be consumed from an external module or not. That is achieved using the /_bundle_/ magic comment placed on the export.

<Code>
{`
export /*bundle*/ class Auth {
    //....
}

`}

</Code>

Internal modules can be imported by any other internal module, thriough the relative file path.

<SubTitle>Modules</SubTitle>

As mentioned before, they represent the minimum development unit of BeyondJS and it is composed of all the internal modules that it requires.

It allows the concept of a module in BeyondJS to be closer to the definition of a module in general IT, where it represents functionality within a program or system. Although JavaScript modules are compatible with this concept, in practice a module (under the computing concept) of a project, application, or library contains a whole set of JavaScript modules (internal modules in BeyondJS), together with the rest of the tools and technologies required to compose it, such as styles, images or text.

In other words, BeyondJS is the container of all the tools and technologies necessary to ensure the complete functioning of functionality represents a developed functionality and where the developer can define what he wants to export so that can be consumed externally and what not.

<SubTitle>Working with modules</SubTitle>

Modules must be contained in a project and are consumed by it, but they can also be used by other projects that import them as libraries.

BeyondJS handles the import of modules via the npm spec, allows you to define the structure@scope/project-name/module-name. The scope is an optional value, and along with the project name are properties defined in the project configuration and are found in the <Link to="/project#properties">project.json.</Link>

The module name definition is a vital feature in BeyondJS. It helps with future maintenance of the project, allowing modules and folders for restructiring without the behavior of the module being compromissed by imports.

When BeyondJS brings up the development environment, it performs a mapping of the existing modules, and interprets the paths of each module to be able to reference them correctly when imported. Later on, in the deployment phase, it is in charge of assembling the necessary structure and converting the imports.

<SubTitle>Identifier of a module</SubTitle>

The identifier of a module is the one used to import it

<Code>
	{`
import * as Mod from 'module-identifier';
`}
</Code>

In BeyondJS, identifiers are defined by the bundle (project) identifier, and the module name.

To exemplify it, suppose a "project" project is created under the @company scope, then we add a module named login the path to import this module would be:

<Code>
	{`
@company/project/login
`}
</Code>

Now, modules are containers for bundles and bundles represent the final included file. Therefore, to import an unbundle, it is necessary to specify the bundle to consume.

To exemplify it, suppose we have a bundle code that makes an Auth object available inside the login module that we have created. Our import would be as follows:

<Code>
	{`
import {Auth} from '@company/project/login/code';
`}
</Code>

-   <Link to="/docs/modules/config">Module configuration</Link>
-   <Link to="/docs/bundles">Bundles</Link>
