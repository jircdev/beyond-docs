import { Title, Subtitle, DocHeader } from "@beyond/docs/components/html";
import { Link } from "@beyond/docs/components/html";
import { Code } from "@beyond/docs/code";

<Title>Routing</Title>

BeyondJS has simple and powerful route handling at the same time. For most cases, the URLs are defined in the configuration of page type widgets, through the URL property, but there may be cases where some more advanced configuration is required.

Note: This chapter covers the documentation of the routing object. If you want to learn about the handling of parameters in the URL of a page, you can read about it in the <Link to="/docs/widgets/page">Page widgets chapter.</Link>

<Subtitle>Routing object</Subtitle>

The routing object manages the history of the browser and handles compatibility for web and mobile projects. It offers an API that allows you to work with the history and manipulate it.

It is made available by the kernel and is imported as follows:

<Code>
{`
    "@beyond-js/kernel/routing/ts";

`}

</Code>

The BeyondJS routing object exists to cover the following scenarios:

-   Provide the developer with a simple API to perform complex URL treatments, such as validations, redirections, and variable management.
-   Identify the flow and history of user navigation within the applicative. The history object of the browser has a very limited treatment of it, and only allows access to the number of existing navigations. BeyondJS on the other hand manages a detailed history.
-   Since hybrid applications made with JavaScript resolve file handlingutilizing a different protocol than applications accessed from a browser, BeyondJS treats it to abstract the developer from it and ensure the same behavior regardless of the platform they are working.

<Subtitle>Navigation</Subtitle>

To maintain compatibility with the known APIs, the Routing object has methods homologous to the ones of the browser history API. They cover equal needs, but at the same time, they are in charge of unifying the behaviors between the platforms and updating the elements of the history of BeyondJS.

The available methods are:

**routing.pushState**

Record a new item in the history

<Code>
    {`
routing.pushState('/home', [{state}]);
`}
</Code>

**routing.replaceState**

Modify the current URL without adding new items to the history.

<Code>
    {`
routing.replaceState('/home', [{state}]);
`}
</Code>

It has the same interface as the pushState method of the history object of the Web API, and additionally, it is in charge of updating the history of BeyondJS.

<Subtitle>Route Override</Subtitle>

**routing.redirect**

Generally, although there may be more, there are two typical contexts in which it is necessary to treat URLs:

-   When it is required to manage friendly URLs.
-   When it is necessary to validate access permissions and, if the person trying to access the URL does not have them, it is intended to redirect to a specific flow.

For this type of case, an asyncronaredirect function can be defined as a property of the routing object. This function receives an object of type <Link to="/api/uri">{`<URI>`}</Link> that has a property pathname that represents the current path.

The redirect function can return an undefined or a string. If an undefined is returned, the navigation flow will continue without interruption. If a string is returned, it will be considered as the final URL, and BeyondJS will redirect to the returned URL.

<Code>
{`
routing.redirect = async function redirect(uri): Promise[string] {
	return '/';
};

`}

</Code>

In the example above, any route received is redirected to /.

<Subtitle>Handling of URLs not found.</Subtitle>

The routing object has a `missing` property that can be defined as an asynchronous function and returns the name of the widget you want to display in case the requested URL is not found.

A typical example of use, is to implement a 404 screen for a page not found.

A basic implementation could be the following:

<Code>
{`
routing.missing = async (pathname: String) => {
   return 'app-docs-missing';
}

`}

</Code>

In the above example, the name of a widget is returned. BeyondJS will validate that the widget exists when the URL is not fetched and display it as an error page.
