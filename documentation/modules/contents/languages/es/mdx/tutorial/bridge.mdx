import { DocHeader, BeyondName, Subtitle, Link } from '@beyond/docs/components/html';
import { Code } from '@beyond/docs/code';

<DocHeader pretitle="Tutorial" title="Código Bridge" />
Como mencionamos antes, en esta parte generalmente cada proyecto tiene su propia lógica para la validación de sesión. La intención hoy no es enfocarse en cómo debe manejarse esto, lo que haremos será crear un código básico que nos permita conectar nuestro código cliente con el backend
node. Esto lo agregaremos en el archivo bridge.ts existente en el módulo que acabamos de crear.

<Code>
	{`
const data = {
    user: 'admin',
    password: '123456.'
}
`}
</Code>

<Code>
{`
export /*actions*//*bundle*/
class Auth {

    async login(user: string, password: string) {
        if (user !== data.user || password !== data.password) {
            return {status: true, error: 'Invalid data'};
        }

        return {status: true, data: {valid: true}}
    }

}
`}

</Code>

El código es bastante simple, pero hay varios puntos interesantes a destacar

El comentario mágico /_bundle_/es utilizado por Beyond para identificar que el código a continuación debe ser considerado como código a exportar en el bundle final. Si quieres leer más acerca del funcionamiento de bundles y módulos, te recomendamos ir a La seccion de módulos de la documentacion.
El comentario mágico /_actions_/es utilizado por Beyond para identificar que segmentos del bundle bridge deben quedar disponibles como acciones que puedan ser consumidas por el cliente.
La respuesta del método login es un objeto plano que llega con la estructura definida al cliente.
Conectar cliente y servidor
El bridge que creamos es un servicio node. Generalmente, para ejecutar un servicio node, es necesario ir a una consola. Sin embargo, en BeyondJS estos servicios funcionan como un BEE (Beyond Environment Service) y para ejecutarlo debemos ir al Dashboard y darle al botón de ejecución, que podemos encontrar en la pantalla de detalle del proyecto.

Y otro en el detalle del proyecto:

Beyond Environment Execution - Dashboard - BeyondJs
Para poder implementar la funcionalidad de login con nuestro servidor, debemos importar nuestro objeto auth en el código cliente y asociar el evento onSubmit a nuestro formulario.

En BeyondJS los proyectos siguen las mismas directrices para especificación y resolución de nombres y paquetes que npm, de la misma forma que lo hace typescript. Deben tener nombre de módulo y pueden manejar un scope también. En nuestro caso, definimos ambos al momento de crear nuestro proyecto y módulo respectivamente.

A continuación, en nuestro componente Page importamos el objeto Auth

<Code>{`import {Auth} from "@testing/login/home/bridge";`}</Code>

Agregamos nuestra función onSubmit y la asociamos al formulario, nuestro código debe quedar de la siguiente forma:

<Code>
{`
import * as React from 'react';
import { Auth } from '@testing/login/auth';

interface IForm {
disabled?: boolean;
}
const model = new Auth();
export /_page_/
function View(): JSX.Element {
const defaultValues = {username: '', password: '', fetching: false};
const [values, setValues] = React.useState(defaultValues);
const [error, setError] = React.useState();
const handleChange = ({currentTarget: target}) => {
const currentValue = {...values};
currentValue[target.name] = target.value;
setValues(currentValue);
};
const formDisabled: IForm = {};
const {username, password} = values;
if (!username || !password) {
formDisabled.disabled = true;
}
const onSubmit = async event => {
try {
event.preventDefault();
const response = await model.login(username, password);
if (response.data?.valid) {
console.log('valid data');
return;
}
setError(response.error);
} catch (e) {
console.log(e)
}
}

     return (
        <div className="page__container">
            <form onSubmit={onSubmit}>
                {
                    error &&
                    <div className="form__error">
                        {error}
                    </div>
                }
                <label>User: </label>
                <input onChange={handleChange} type="text" name="username"/>
                <label>Password</label>
                <input onChange={handleChange} type="password" name="password"/>
                <div className="form__actions">
                    <button onClick={onSubmit} {...formDisabled}>Login</button>
                </div>
            </form>
        </div>
    );

}`}

</Code>

Es tiempo de probar nuestro formulario. Si agregamos los datos correctos, podremos ver que en la consola del navegador aparece el mensaje que indica que los datos fueron validados y se puede iniciar sesión, si por el contrario, agregamos datos incorrectos, podremos ver como aparece el mensaje de error "Invalid data" el cual actualizamos en la variable de estado del componente.

Resumen:

Creamos un módulo con un widget de tipo page.
Creamos una conexión con un backend node por medio del bundle bridge.
Repasamos la estructura de resolución de módulos para importar el bridge Auth y poder agregar la validación de inicio de sesión.
Ahora solo nos falta redireccionar al usuario a una pantalla de bienvenida.

-   <Link to="/docs/tutorial/routing">Enrutamiento</Link>
